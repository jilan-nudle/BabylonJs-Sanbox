<!doctype html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/addons/babylonjs.addons.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <body>
        <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
        <script>
                    var canvas = document.getElementById("renderCanvas");

                    var startRenderLoop = function (engine, canvas) {
                        engine.runRenderLoop(function () {
                            if (sceneToRender && sceneToRender.activeCamera) {
                                sceneToRender.render();
                            }
                        });
                    }

                    var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };

        // ADD CODE HERE =================================================================================

        const createScene = async() => {
    const scene = new BABYLON.Scene(engine);

    // camera
    const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 3, 3), scene);
    camera.setTarget(BABYLON.Vector3.Zero());

    camera.attachControl(canvas, true);

    const light = new BABYLON.HemisphericLight("light1", 
        new BABYLON.Vector3(0,1,0));

    // Public vars
    let isPlaced = false;

    // end

    /*const box = BABYLON.MeshBuilder.CreateBox("box1", {});
    box.isVisible = false;*/

    const model = "assets/animated_triceratops_skeleton.glb";
    const asset = await BABYLON.LoadAssetContainerAsync(model, scene);



    // Adding debug text.
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    var debugText = new BABYLON.GUI.TextBlock();
    debugText.text = "NA";
    debugText.color = "green";
    advancedTexture.addControl(debugText);


    // Enabling Augmented Reality
    const xr = await scene.createDefaultXRExperienceAsync(
        {
            uiOptions:
            {
                sessionMode: "immersive-ar",
            },
            optionalFeatures: ["hit-test"],
        }
    );

    // Enabling hit test
    const featureManager = xr.baseExperience.featuresManager;
    const hitTest = featureManager.enableFeature(BABYLON.WebXRHitTest, 
        "latest");


    // Creating dot
    const dot = BABYLON.MeshBuilder.CreateTorus('marker', { diameter: 0.15, thickness: 0.05, tessellation: 32 });

    debugText.text = "X5";
    dot.isVisible = false;

    let markerPosition = new BABYLON.Vector3();
    let markerScaling = new BABYLON.Vector3();
    let markerRotation = new BABYLON.Quaternion();

    hitTest.onHitTestResultObservable.add((result) => {
        if(result.length && isPlaced == false)
        {
            dot.isVisible = true;
            result[0].transformationMatrix.decompose(dot.scaling, dot.rotationQuaternion, dot.position);
            
            result[0].transformationMatrix.decompose(markerScaling, markerRotation, markerPosition);
            debugText.text = markerPosition;
        }else
        {
            dot.isVisible = false;
        }
    });


    const label = new BABYLON.GUI.Rectangle("label");
    label.background = "black"
    label.height = "60px";
    label.alpha = 0.5;
    label.width = "200px";
    label.cornerRadius = 20;
    label.thickness = 1;
    label.zIndex = 5;

    advancedTexture.addControl(label);

    const caption = new BABYLON.GUI.TextBlock();
    label.addControl(caption);

    scene.onPointerDown = (evt, pickInfo) => {
        debugText.text = "xr.baseExperience.state";
        if(hitTest && xr.baseExperience.state === BABYLON.WebXRState.IN_XR && isPlaced == false)
        {
            isPlaced = true;
            asset.addAllToScene();
            dot.isVisible = false;

            label.linkWithMesh(asset.meshes[0]);

            asset.meshes.forEach((mesh) => {
                if(mesh instanceof BABYLON.Mesh)
                {
                    mesh.isVisible = true;
                    mesh.position = markerPosition.clone();
                    mesh.rotationQuaternion = markerRotation.clone();
                    mesh.scaling = new BABYLON.Vector3(0.3, 0.3, 0.3);
                }
            });

        }
    }


    return scene;

}


    // END =========================================================================



                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
                    
                    const engineOptions = window.engine.getCreationOptions?.();
                    if (!engineOptions || engineOptions.audioEngine !== false) {
                        
                    }
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {scene.then(returnedScene => { sceneToRender = returnedScene; });
        
                    });

                    // Resize
                    window.addEventListener("resize", function () {
                        engine.resize();
                    });
        </script>
    </body>
</html>
